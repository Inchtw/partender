{"version":3,"file":"75.main.js","mappings":"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","sources":["webpack://partender-website/./node_modules/@firebase/installations/dist/esm/index.esm2017.js","webpack://partender-website/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js"],"sourcesContent":["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { openDB } from 'idb';\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.9\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PENDING_TIMEOUT_MS = 10000;\r\nconst PACKAGE_VERSION = `w:${version}`;\r\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nconst SERVICE = 'installations';\r\nconst SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERROR_DESCRIPTION_MAP = {\r\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\r\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',\r\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\r\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',\r\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof FirebaseError &&\r\n        error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint({ projectId }) {\r\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* RequestStatus.COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nasync function getErrorFromResponse(requestName, response) {\r\n    const responseJson = await response.json();\r\n    const errorData = responseJson.error;\r\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */, {\r\n        requestName,\r\n        serverCode: errorData.code,\r\n        serverMessage: errorData.message,\r\n        serverStatus: errorData.status\r\n    });\r\n}\r\nfunction getHeaders({ apiKey }) {\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\r\n    const headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nasync function retryIfServerError(fn) {\r\n    const result = await fn();\r\n    if (result.status >= 500 && result.status < 600) {\r\n        // Internal Server Error. Retry request.\r\n        return fn();\r\n    }\r\n    return result;\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\r\n    const endpoint = getInstallationsEndpoint(appConfig);\r\n    const headers = getHeaders(appConfig);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        fid,\r\n        authVersion: INTERNAL_AUTH_VERSION,\r\n        appId: appConfig.appId,\r\n        sdkVersion: PACKAGE_VERSION\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const registeredInstallationEntry = {\r\n            fid: responseValue.fid || fid,\r\n            registrationStatus: 2 /* RequestStatus.COMPLETED */,\r\n            refreshToken: responseValue.refreshToken,\r\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n        };\r\n        return registeredInstallationEntry;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Create Installation', response);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    const b64 = btoa(String.fromCharCode(...array));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nconst INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        const fidByteArray = new Uint8Array(17);\r\n        const crypto = self.crypto || self.msCrypto;\r\n        crypto.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\r\n        const fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return `${appConfig.appName}!${appConfig.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    const key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    const key = getKey(appConfig);\r\n    let callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    const key = getKey(appConfig);\r\n    const callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    const callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    for (const callback of callbacks) {\r\n        callback(fid);\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    const channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key, fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nlet broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = e => {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DATABASE_NAME = 'firebase-installations-database';\r\nconst DATABASE_VERSION = 1;\r\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(OBJECT_STORE_NAME);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nasync function set(appConfig, value) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await objectStore.get(key));\r\n    await objectStore.put(value, key);\r\n    await tx.done;\r\n    if (!oldValue || oldValue.fid !== value.fid) {\r\n        fidChanged(appConfig, value.fid);\r\n    }\r\n    return value;\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nasync function remove(appConfig) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\r\n    await tx.done;\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nasync function update(appConfig, updateFn) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await store.get(key));\r\n    const newValue = updateFn(oldValue);\r\n    if (newValue === undefined) {\r\n        await store.delete(key);\r\n    }\r\n    else {\r\n        await store.put(newValue, key);\r\n    }\r\n    await tx.done;\r\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n        fidChanged(appConfig, newValue.fid);\r\n    }\r\n    return newValue;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nasync function getInstallationEntry(installations) {\r\n    let registrationPromise;\r\n    const installationEntry = await update(installations.appConfig, oldEntry => {\r\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\r\n        registrationPromise = entryWithPromise.registrationPromise;\r\n        return entryWithPromise.installationEntry;\r\n    });\r\n    if (installationEntry.fid === INVALID_FID) {\r\n        // FID generation failed. Waiting for the FID from the server.\r\n        return { installationEntry: await registrationPromise };\r\n    }\r\n    return {\r\n        installationEntry,\r\n        registrationPromise\r\n    };\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    const entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */));\r\n            return {\r\n                installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        const inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        return {\r\n            installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(installations)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nasync function registerInstallation(installations, installationEntry) {\r\n    try {\r\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\r\n        return set(installations.appConfig, registeredInstallationEntry);\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) && e.customData.serverCode === 409) {\r\n            // Server returned a \"FID cannot be used\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            // Registration failed. Set FID as not registered.\r\n            await set(installations.appConfig, {\r\n                fid: installationEntry.fid,\r\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n            });\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nasync function waitUntilFidRegistration(installations) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateInstallationRequest(installations.appConfig);\r\n    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // createInstallation request still in progress.\r\n        await sleep(100);\r\n        entry = await updateInstallationRequest(installations.appConfig);\r\n    }\r\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\r\n        if (registrationPromise) {\r\n            return registrationPromise;\r\n        }\r\n        else {\r\n            // if there is no registrationPromise, entry is registered.\r\n            return installationEntry;\r\n        }\r\n    }\r\n    return entry;\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\r\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        installation: {\r\n            sdkVersion: PACKAGE_VERSION,\r\n            appId: appConfig.appId\r\n        }\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n        return completedAuthToken;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Generate Auth Token', response);\r\n    }\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nasync function refreshAuthToken(installations, forceRefresh = false) {\r\n    let tokenPromise;\r\n    const entry = await update(installations.appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n            // There is a valid token in the DB.\r\n            return oldEntry;\r\n        }\r\n        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // There already is a token request in progress.\r\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\r\n            return oldEntry;\r\n        }\r\n        else {\r\n            // No token or token expired.\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\r\n            return inProgressEntry;\r\n        }\r\n    });\r\n    const authToken = tokenPromise\r\n        ? await tokenPromise\r\n        : entry.authToken;\r\n    return authToken;\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateAuthTokenRequest(installations.appConfig);\r\n    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // generateAuthToken still in progress.\r\n        await sleep(100);\r\n        entry = await updateAuthTokenRequest(installations.appConfig);\r\n    }\r\n    const authToken = entry.authToken;\r\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        return refreshAuthToken(installations, forceRefresh);\r\n    }\r\n    else {\r\n        return authToken;\r\n    }\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\r\n    try {\r\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\r\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\r\n        await set(installations.appConfig, updatedInstallationEntry);\r\n        return authToken;\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) &&\r\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\r\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n            await set(installations.appConfig, updatedInstallationEntry);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    const now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    const inProgressAuthToken = {\r\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function getId(installations) {\r\n    const installationsImpl = installations;\r\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\r\n    if (registrationPromise) {\r\n        registrationPromise.catch(console.error);\r\n    }\r\n    else {\r\n        // If the installation is already registered, update the authentication\r\n        // token if needed.\r\n        refreshAuthToken(installationsImpl).catch(console.error);\r\n    }\r\n    return installationEntry.fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getToken(installations, forceRefresh = false) {\r\n    const installationsImpl = installations;\r\n    await completeInstallationRegistration(installationsImpl);\r\n    // At this point we either have a Registered Installation in the DB, or we've\r\n    // already thrown an error.\r\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\r\n    return authToken.token;\r\n}\r\nasync function completeInstallationRegistration(installations) {\r\n    const { registrationPromise } = await getInstallationEntry(installations);\r\n    if (registrationPromise) {\r\n        // A createInstallation request is in progress. Wait until it finishes.\r\n        await registrationPromise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteInstallationRequest(appConfig, installationEntry) {\r\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    const request = {\r\n        method: 'DELETE',\r\n        headers\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (!response.ok) {\r\n        throw await getErrorFromResponse('Delete Installation', response);\r\n    }\r\n}\r\nfunction getDeleteEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function deleteInstallations(installations) {\r\n    const { appConfig } = installations;\r\n    const entry = await update(appConfig, oldEntry => {\r\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n            // Delete the unregistered entry without sending a deleteInstallation request.\r\n            return undefined;\r\n        }\r\n        return oldEntry;\r\n    });\r\n    if (entry) {\r\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // Can't delete while trying to register.\r\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */);\r\n        }\r\n        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) {\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            else {\r\n                await deleteInstallationRequest(appConfig, entry);\r\n                await remove(appConfig);\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */\r\nfunction onIdChange(installations, callback) {\r\n    const { appConfig } = installations;\r\n    addCallback(appConfig, callback);\r\n    return () => {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */\r\nfunction getInstallations(app = getApp()) {\r\n    const installationsImpl = _getProvider(app, 'installations').getImmediate();\r\n    return installationsImpl;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    const configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    for (const keyName of configKeys) {\r\n        if (!app.options[keyName]) {\r\n            throw getMissingValueError(keyName);\r\n        }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, {\r\n        valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INSTALLATIONS_NAME = 'installations';\r\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\r\nconst publicFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Throws if app isn't configured properly.\r\n    const appConfig = extractAppConfig(app);\r\n    const heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n    const installationsImpl = {\r\n        app,\r\n        appConfig,\r\n        heartbeatServiceProvider,\r\n        _delete: () => Promise.resolve()\r\n    };\r\n    return installationsImpl;\r\n};\r\nconst internalFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Internal FIS instance relies on public FIS instance.\r\n    const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();\r\n    const installationsInternal = {\r\n        getId: () => getId(installations),\r\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\r\n    };\r\n    return installationsInternal;\r\n};\r\nfunction registerInstallations() {\r\n    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n}\n\n/**\r\n * The Firebase Installations Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterInstallations();\r\nregisterVersion(name, version);\r\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\nregisterVersion(name, version, 'esm2017');\n\nexport { deleteInstallations, getId, getInstallations, getToken, onIdChange };\n//# sourceMappingURL=index.esm2017.js.map\n","import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-initialized instance.',\r\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.',\r\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */]: 'The \"client_id\" field is empty.',\r\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies and creates a TrustedScriptURL.\r\n */\r\nfunction createGtagTrustedTypesScriptURL(url) {\r\n    if (!url.startsWith(GTAG_URL)) {\r\n        const err = ERROR_FACTORY.create(\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */, {\r\n            gtagURL: url\r\n        });\r\n        logger.warn(err.message);\r\n        return '';\r\n    }\r\n    return url;\r\n}\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\r\n *\r\n * @param policyName A string containing the name of the policy\r\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\r\n * | the TrustedTypePolicy reference documentation}.\r\n */\r\nfunction createTrustedTypesPolicy(policyName, policyOptions) {\r\n    // Create a TrustedTypes policy that we can use for updating src\r\n    // properties\r\n    let trustedTypesPolicy;\r\n    if (window.trustedTypes) {\r\n        trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\r\n    }\r\n    return trustedTypesPolicy;\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const trustedTypesPolicy = createTrustedTypesPolicy('firebase-js-sdk-policy', {\r\n        createScriptURL: createGtagTrustedTypesScriptURL\r\n    });\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    const gtagScriptURL = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\r\n    script.src = trustedTypesPolicy\r\n        ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL)\r\n        : gtagScriptURL;\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* GtagCommand.EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever initialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, ...args) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* GtagCommand.EVENT */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* GtagCommand.CONFIG */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"consent\" /* GtagCommand.CONSENT */) {\r\n                const [consentAction, gtagParams] = args;\r\n                // consentAction can be one of 'default' or 'update'.\r\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */, consentAction, gtagParams);\r\n            }\r\n            else if (command === \"get\" /* GtagCommand.GET */) {\r\n                const [measurementId, fieldName, callback] = args;\r\n                gtagCore(\"get\" /* GtagCommand.GET */, measurementId, fieldName, callback);\r\n            }\r\n            else if (command === \"set\" /* GtagCommand.SET */) {\r\n                const [customParams] = args;\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* GtagCommand.SET */, customParams);\r\n            }\r\n            else {\r\n                gtagCore(command, ...args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns the script tag in the DOM matching both the gtag url pattern\r\n * and the provided data layer name.\r\n */\r\nfunction findGtagScriptOnPage(dataLayerName) {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src &&\r\n            tag.src.includes(GTAG_URL) &&\r\n            tag.src.includes(dataLayerName)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    var _a;\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        const error = e;\r\n        if (!isRetriableError(error)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503\r\n            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\r\nlet defaultEventParametersForInit;\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n */\r\nasync function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\r\n    const measurementId = await initializationPromise;\r\n    return new Promise((resolve, reject) => {\r\n        gtagFunction(\"get\" /* GtagCommand.GET */, measurementId, 'client_id', (clientId) => {\r\n            if (!clientId) {\r\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */));\r\n            }\r\n            resolve(clientId);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\r\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\r\nlet defaultConsentSettingsForInit;\r\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction _setConsentDefaultForInit(consentSettings) {\r\n    defaultConsentSettingsForInit = consentSettings;\r\n}\r\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\r\nfunction _setDefaultEventParametersForInit(customParams) {\r\n    defaultEventParametersForInit = customParams;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    if (!isIndexedDBAvailable()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await validateIndexedDBOpenable();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\r\n    // data layer name.\r\n    if (!findGtagScriptOnPage(dataLayerName)) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // Detects if there are consent settings that need to be configured.\r\n    if (defaultConsentSettingsForInit) {\r\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);\r\n        _setConsentDefaultForInit(undefined);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    // Detects if there is data that will be set on every event logged from the SDK.\r\n    if (defaultEventParametersForInit) {\r\n        gtagCore(\"set\" /* GtagCommand.SET */, defaultEventParametersForInit);\r\n        _setDefaultEventParametersForInit(undefined);\r\n    }\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if (isBrowserExtension()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = getApp()) {\r\n    app = getModularInstance(app);\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if (deepEqual(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if (isBrowserExtension()) {\r\n        return false;\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        return false;\r\n    }\r\n    if (!isIndexedDBAvailable()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await validateIndexedDBOpenable();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nasync function getGoogleAnalyticsClientId(analyticsInstance) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\r\nfunction setDefaultEventParameters(customParams) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */, customParams);\r\n    }\r\n    else {\r\n        _setDefaultEventParametersForInit(customParams);\r\n    }\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction setConsent(consentSettings) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */, 'update', consentSettings);\r\n    }\r\n    else {\r\n        _setConsentDefaultForInit(consentSettings);\r\n    }\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.8\";\n\n/**\r\n * The Firebase Analytics Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    registerVersion(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\nexport { getAnalytics, getGoogleAnalyticsClientId, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };\n//# sourceMappingURL=index.esm2017.js.map\n"],"names":["version","PACKAGE_VERSION","INTERNAL_AUTH_VERSION","ERROR_FACTORY","isServerError","error","code","includes","getInstallationsEndpoint","projectId","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","replace","creationTime","Date","now","async","getErrorFromResponse","requestName","errorData","json","create","serverCode","serverMessage","message","serverStatus","status","getHeaders","apiKey","Headers","Accept","retryIfServerError","fn","result","sleep","ms","Promise","resolve","setTimeout","VALID_FID_PATTERN","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","fid","array","btoa","String","fromCharCode","substr","encode","test","_a","getKey","appConfig","appName","appId","fidChangeCallbacks","Map","fidChanged","key","callFidChangeCallbacks","channel","broadcastChannel","BroadcastChannel","onmessage","e","data","postMessage","size","close","broadcastFidChange","callbacks","get","callback","OBJECT_STORE_NAME","dbPromise","getDbPromise","upgrade","db","oldVersion","createObjectStore","set","value","tx","transaction","objectStore","oldValue","put","done","remove","delete","update","updateFn","store","newValue","undefined","getInstallationEntry","installations","registrationPromise","installationEntry","oldEntry","clearTimedOutRequest","registrationStatus","updateOrCreateInstallationEntry","entryWithPromise","navigator","onLine","reject","inProgressEntry","registrationTime","registeredInstallationEntry","heartbeatServiceProvider","endpoint","headers","heartbeatService","getImmediate","optional","heartbeatsHeader","getHeartbeatsHeader","append","body","authVersion","sdkVersion","request","method","JSON","stringify","fetch","ok","responseValue","refreshToken","authToken","createInstallationRequest","customData","registerInstallation","waitUntilFidRegistration","triggerRegistrationIfNecessary","entry","updateInstallationRequest","generateAuthTokenRequest","getGenerateAuthTokenEndpoint","getAuthorizationHeader","getHeadersWithAuth","installation","refreshAuthToken","forceRefresh","tokenPromise","isEntryRegistered","oldAuthToken","isAuthTokenExpired","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","Object","assign","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","getMissingValueError","valueName","INSTALLATIONS_NAME","container","app","getProvider","options","name","configKeys","keyName","extractAppConfig","_delete","getId","installationsImpl","catch","console","getToken","completeInstallationRegistration","ANALYTICS_TYPE","GTAG_URL","logger","createGtagTrustedTypesScriptURL","url","startsWith","err","gtagURL","warn","promiseAllSettled","promises","all","map","promise","defaultRetryData","constructor","throttleMetadata","intervalMillis","this","getThrottleMetadata","setThrottleMetadata","metadata","deleteThrottleMetadata","fetchDynamicConfigWithRetry","retryData","timeoutMillis","measurementId","backoffCount","throttleEndTimeMillis","signal","AnalyticsAbortSignal","abort","attemptFetchDynamicConfigWithRetry","appFields","backoffMillis","Math","max","timeout","addEventListener","clearTimeout","setAbortableTimeout","appUrl","errorMessage","jsonResponse","_ignored","httpStatus","responseMessage","fetchDynamicConfig","isRetriableError","debug","listeners","listener","push","forEach","defaultEventParametersForInit","defaultConsentSettingsForInit","_initializeAnalytics","dynamicConfigPromisesList","measurementIdToAppId","gtagCore","dataLayerName","dynamicConfigPromise","then","config","fidPromise","errorInfo","toString","validateIndexedDB","envIsValid","dynamicConfig","scriptTags","window","document","getElementsByTagName","tag","values","src","findGtagScriptOnPage","trustedTypesPolicy","policyName","policyOptions","trustedTypes","createPolicy","createTrustedTypesPolicy","createScriptURL","script","createElement","gtagScriptURL","head","appendChild","insertScriptTag","configProperties","AnalyticsService","initializationPromisesMap","gtagCoreFunction","wrappedGtagFunction","globalInitDone","factory","mismatchedEnvMessages","length","details","index","join","warnOnBrowserContextMismatch","id","dataLayer","Array","isArray","getOrCreateDataLayer","wrappedGtag","gtagFunctionName","_args","arguments","command","args","gtagParams","initializationPromisesToWaitFor","gaSendToList","dynamicConfigResults","sendToId","foundConfig","find","initializationPromise","gtagOnEvent","correspondingAppId","gtagOnConfig","consentAction","fieldName","customParams","wrapGtag","wrapOrCreateGtag","getAnalytics","analyticsProvider","isInitialized","existingInstance","getOptions","initialize","initializeAnalytics","analyticsOptions","analytics","logEvent","eventName","eventParams","analyticsInstance","gtagFunction","global","logEvent$1","reason"],"sourceRoot":""}